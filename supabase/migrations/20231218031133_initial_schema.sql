create extension if not exists "vector" with schema "extensions";


create type "public"."organization_user_role" as enum ('admin', 'employee');

create type "public"."timelog_type" as enum ('in', 'out');

create table "public"."organization" (
    "id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text default ''::text
);


alter table "public"."organization" enable row level security;

create table "public"."timelog" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "type" timelog_type not null,
    "organization_id" uuid not null default auth.uid()
);


alter table "public"."timelog" enable row level security;

create table "public"."user" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "avatar_embedding" vector(512),
    "first_name" text not null default ''::text,
    "last_name" text not null default ''::text,
    "organization_id" uuid not null default auth.uid()
);


alter table "public"."user" enable row level security;

CREATE UNIQUE INDEX organization_pkey ON public.organization USING btree (id);

CREATE UNIQUE INDEX timelog_pkey ON public.timelog USING btree (id);

CREATE UNIQUE INDEX user_pkey ON public."user" USING btree (id);

alter table "public"."organization" add constraint "organization_pkey" PRIMARY KEY using index "organization_pkey";

alter table "public"."timelog" add constraint "timelog_pkey" PRIMARY KEY using index "timelog_pkey";

alter table "public"."user" add constraint "user_pkey" PRIMARY KEY using index "user_pkey";

alter table "public"."organization" add constraint "organization_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) not valid;

alter table "public"."organization" validate constraint "organization_id_fkey";

alter table "public"."timelog" add constraint "timelog_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES organization(id) not valid;

alter table "public"."timelog" validate constraint "timelog_organization_id_fkey";

alter table "public"."timelog" add constraint "timelog_user_id_fkey" FOREIGN KEY (user_id) REFERENCES "user"(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."timelog" validate constraint "timelog_user_id_fkey";

alter table "public"."user" add constraint "user_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES organization(id) not valid;

alter table "public"."user" validate constraint "user_organization_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.face_recognition(query_embedding vector, match_threshold double precision, match_count integer)
 RETURNS TABLE(id uuid, first_name text, similarity double precision)
 LANGUAGE sql
 STABLE
AS $function$
select
    id,
    first_name,
    1 - (avatar_embedding <=> query_embedding) as similarity
from public.user
where 1 - (avatar_embedding <=> query_embedding) > match_threshold
order by similarity desc
limit match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  insert into public.organization (id)
  values (new.id);
  return new;
end;
$function$
;

create policy "Enable ALL for users based on user_id"
on "public"."organization"
as permissive
for all
to authenticated
using ((auth.uid() = id))
with check (true);


create policy "Enable ALL for users based on user_id"
on "public"."timelog"
as permissive
for all
to authenticated
using ((auth.uid() = organization_id))
with check ((auth.uid() = organization_id));


create policy "Enable ALL for users based on organization_id"
on "public"."user"
as permissive
for all
to authenticated
using ((auth.uid() = organization_id))
with check ((auth.uid() = organization_id));



